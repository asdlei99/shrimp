<shrimp name="new_scene" authors="">
	<about/>
	<network>
		<block id="Add" position_x="5" position_y="2" author="rconstruct">
			<input name="A" type="point" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="p" output="P"/>
			</input>
			<input name="B" type="point" storage="varying" multi="+" value="1" description="2nd or subsequent inputs" type_parent="value">
				<connection parent="Normal2Vector" output="value"/>
			</input>
			<output name="value" type="point" storage="varying" description="val = A + B"/>
			<rsl_code>
		$(value) = $(A) + $(B);
													</rsl_code>
			<rsl_include/>
			<usage>Adds 2 or more inputs. All the input pads will inherit the type of the output pad.												</usage>
		</block>
		<block id="Add_2" position_x="11" position_y="-4" author="rconstruct">
			<input name="A" type="color" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Multiply_7" output="value"/>
			</input>
			<input name="B" type="color" storage="varying" multi="+" value="1" description="2nd or subsequent inputs" type_parent="value">
				<connection parent="CookTorrance" output="Ci"/>
			</input>
			<output name="value" type="color" storage="varying" description="val = A + B"/>
			<rsl_code>
		$(value) = $(A) + $(B);
				</rsl_code>
			<rsl_include/>
			<usage>Adds 2 or more inputs. All the input pads will inherit the type of the output pad.			</usage>
		</block>
		<block id="AmbientLight" position_x="11" position_y="-8" author="rconstruct">
			<input name="intensity" type="float" storage="varying" value="1" description="Light intensity"/>
			<input name="lightcolor" type="color" storage="varying" value="color( 1, .93, .81 )" description="Light color"/>
			<input name="category" type="string" storage="uniform" value="&quot;&quot;" description="Light category"/>
			<output name="Cl" type="color" storage="varying" description="Light ray color"/>
			<rsl_code>
		__category = $(category);
		$(Cl) = $(intensity) * $(lightcolor);
		L = vector(0);
										</rsl_code>
			<rsl_include/>
			<usage>Ambient light shader.									</usage>
		</block>
		<block id="Area" position_x="-10" position_y="-5" author="rconstruct">
			<input name="P" type="point" storage="varying" value="P" description="Point to compute area at">
				<connection parent="p" output="P"/>
			</input>
			<input name="strategy" type="string" storage="uniform" value="&quot;shading&quot;" description="Strategy"/>
			<output name="value" type="float" storage="varying" description="Differential surface area at p"/>
			<rsl_code>
	#if RENDERER == aqsis
		$(value) = area( $(P) );
	#else
		$(value) = area( $(P), $(strategy) );
	#endif
							</rsl_code>
			<rsl_include/>
			<usage>Returns the geometric mean of the change of &quot;P&quot; between adjacent samples in each parametric direction. It can be interpreted as the area of the microfacet if the parameter being passed is the surface point &quot;P&quot;. The &quot;strategy&quot; variable can be either &quot;shading&quot;, in which case the micropolygon area is calculated with the surface derivatives, or &quot;dicing&quot;, in which case the micropolygons area will be calculated using their geometry. If unspecified, it defaults to &quot;shading&quot;.						</usage>
		</block>
		<block id="Blend_Ratio" position_x="-3" position_y="1" author="rconstruct">
			<input name="base" type="float" storage="varying" value="1" description="Input value">
				<connection parent="Max" output="value"/>
			</input>
			<input name="exponent" type="float" storage="varying" value="2" description="exponent"/>
			<output name="power" type="float" storage="varying" description="val = A raised to the power x"/>
			<rsl_code>
		$(power) = pow( $(base), $(exponent) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns &quot;base&quot; raised to &quot;exponent&quot;.															</usage>
		</block>
		<block id="CalcNormal" position_x="5" position_y="1" author="rconstruct">
			<input name="P" type="point" storage="varying" value="P" description="Point to calculate normal at">
				<connection parent="Add" output="value"/>
			</input>
			<output name="N" type="normal" storage="varying" description="NN is normal at p"/>
			<rsl_code>
		$(N) = calculatenormal( $(P) );
													</rsl_code>
			<rsl_include/>
			<usage>Returns the surface normal of the given point on the surface. You should always recalculate the normals after a displacement.												</usage>
		</block>
		<block id="Cell3D" position_x="-3" position_y="-7" author="rconstruct">
			<input name="P" type="point" storage="varying" value="P" description="point to sample noise at">
				<connection parent="Voronoi3D2F" output="Ppos1"/>
			</input>
			<input name="amplitude" type="float" storage="varying" value="1" description="Amplitude of noise"/>
			<output name="value" type="float" storage="varying" description="Cell noise value at point p"/>
			<rsl_code>
		$(value) = $(amplitude) * $(value:type) cellnoise( $(P) );
				</rsl_code>
			<rsl_include/>
			<usage>Cellnoise returns a random value between 0 and &quot;amplitude&quot; for each integer &quot;cell&quot;. It&apos;s much cheaper than calling noise.			</usage>
		</block>
		<block id="Clamp" position_x="0.505263157894737" position_y="-5.37894736842105" author="rconstruct">
			<input name="x" type="float" storage="varying" value="1" description="Input value" type_parent="value">
				<connection parent="Subtract_2" output="value"/>
			</input>
			<input name="minimum" type="float" storage="varying" value="0.0" description="minimum value" type_parent="value"/>
			<input name="maximum" type="float" storage="varying" value="1.0" description="maximum value" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="Clamp a between min and max"/>
			<rsl_code>
		$(value) = clamp( $(x), $(minimum), $(maximum) );
							</rsl_code>
			<rsl_include/>
			<usage>Clamps the first argument between the minimum and maximum values provided.						</usage>
		</block>
		<block id="Clamp_2" position_x="8" position_y="0" author="rconstruct">
			<input name="x" type="float" storage="varying" value="1" description="Input value" type_parent="value">
				<connection parent="Fresnel" output="Kr"/>
			</input>
			<input name="minimum" type="float" storage="varying" value="0.0" description="minimum value" type_parent="value"/>
			<input name="maximum" type="float" storage="varying" value="1.0" description="maximum value" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="Clamp a between min and max"/>
			<rsl_code>
		$(value) = clamp( $(x), $(minimum), $(maximum) );
				</rsl_code>
			<rsl_include/>
			<usage>Clamps the first argument between the minimum and maximum values provided.			</usage>
		</block>
		<block id="Clamp_3" position_x="5" position_y="-7" author="rconstruct">
			<input name="x" type="color" storage="varying" value="1" description="Input value" type_parent="value">
				<connection parent="VaryEach" output="value"/>
			</input>
			<input name="minimum" type="color" storage="varying" value="0.0" description="minimum value" type_parent="value"/>
			<input name="maximum" type="color" storage="varying" value="1.0" description="maximum value" type_parent="value"/>
			<output name="value" type="color" storage="varying" description="Clamp a between min and max"/>
			<rsl_code>
		$(value) = clamp( $(x), $(minimum), $(maximum) );
				</rsl_code>
			<rsl_include/>
			<usage>Clamps the first argument between the minimum and maximum values provided.			</usage>
		</block>
		<block id="CookTorrance" position_x="8" position_y="-6" author="rconstruct">
			<input name="Cspec" type="color" storage="varying" value="color(1)" description="Specular color"/>
			<input name="Ks" type="float" storage="varying" value="1.0" description="Specular light coefficient">
				<connection parent="Clamp" output="value"/>
			</input>
			<input name="roughness" type="float" storage="varying" value="0.15" description="The apparent surface roughness."/>
			<input name="distribution" type="float" storage="uniform" value="0" description="Microfacet distributions, see help."/>
			<input name="attenuation" type="float" storage="uniform" value="0" description="Geometric attenuation, see help."/>
			<input name="ior" type="float" storage="varying" value="1.5" description="Index of refraction"/>
			<input name="extinction" type="float" storage="varying" value="2" description="Extinction coefficient"/>
			<input name="samples" type="float" storage="varying" value="64" description="Reflection samples"/>
			<input name="N" type="normal" storage="varying" value="normalize(N)" description="Surface normal"/>
			<input name="I" type="vector" storage="varying" value="I" description="Direction of viewer"/>
			<input name="direction" type="vector" storage="varying" value="dPdv" description="Anisotropy direction"/>
			<input name="category" type="string" storage="uniform" value="&quot;&quot;" description="Light categories accepted"/>
			<output name="Ci" type="color" storage="varying" description="Shaded color"/>
			<rsl_code>
        aov_specularcolor = $(Cspec);

        #if RENDERER==_3delight

        uniform string $(blockname)_raytype = &quot;&quot;;
        rayinfo(&quot;type&quot;, $(blockname)_raytype);

        if ($(blockname)_raytype != &quot;diffuse&quot;)
        {
            aov_specular += $(Ks) *
                cooktorrance(
                    $(N), $(I), $(direction),
                    $(ior), $(extinction), $(roughness),
                    $(distribution), $(attenuation), $(category));

            shader $(blockname)_gi_light = getshader(&quot;gi_light&quot;);

            uniform string $(blockname)_envmap = &quot;&quot;;
            uniform string $(blockname)_envspace = &quot;&quot;;

            if ($(blockname)_gi_light != null)
            {
                $(blockname)_envmap = $(blockname)_gi_light-&gt;envmap;
                $(blockname)_envspace = $(blockname)_gi_light-&gt;envspace;
            }

            aov_reflection += $(Ks) *
                trace(P, $(N), &quot;bsdf&quot;, &quot;cook-torrance&quot;,
                    &quot;wo&quot;, -$(I), &quot;roughness&quot;, $(roughness),
                    &quot;samples&quot;, $(samples), &quot;eta&quot;, $(ior),
                    &quot;samplearealights&quot;, 1,
                    &quot;weight&quot;, $(Cspec),
                    &quot;environmentmap&quot;, $(blockname)_envmap,
                    &quot;environmentspace&quot;, $(blockname)_envspace);
        }

        #else

        uniform string $(blockname)_raytype = &quot;&quot;;
        rayinfo(&quot;type&quot;, $(blockname)_raytype);

        if ($(blockname)_raytype != &quot;diffuse&quot;)
        {
            aov_specular += $(Ks) *
                cooktorrance(
                    $(N), $(I), $(direction),
                    $(ior), $(extinction),
                    $(roughness), $(distribution),
                    $(attenuation), $(category));
        }

        #endif

		$(Ci) = aov_specularcolor * (aov_specular + aov_reflection);

							</rsl_code>
			<rsl_include>rsl_shrimp_shadingmodels.h						</rsl_include>
			<usage>Cook-Torrance specular term. The &quot;distribution&quot; variable controls the microfacet distribution function being used, being 0 = Beckmann (default), 1 = Ward, 2 = Trowbridge-Reitz, 3 = Heidrich-Seidel (anisotropic). The &quot;attenuation&quot; variable controls the geometric attenuation function being used, being 0 = the default shadowing/masking function proposed by Blinn for the Torrance-Sparrow model, 1 = the approximation suggested by Christophe Schlick for the first Smith shadowing/masking equation for a known microfacet normal, 2 = full Smith second equation for an averaged microfacet normal (as used in the He-Torrance model). In the case of the Heidrich-Seidel anisotropic distribution, some literature mentions adding an isotropic specular term, which is added here via &quot;specularbrdf&quot;, but the user might want to override this in the respective header - this distribution uses the anisotropy direction defined by &quot;direction&quot;, which defaults to the global variable &quot;dPdv&quot;. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value is passed to the &quot;aov_specular&quot; AOV presets. The Fresnel term used is the complex Fresnel function, from the Odforce.net Odwiki, courtesy of Mario Marengo and the Odforce community, using the &quot;ior&quot; index of refraction, and the &quot;extinction&quot; extinction coefficient. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.						</usage>
		</block>
		<block id="Displacement_Scale" position_x="0" position_y="2" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Subtract" output="value"/>
			</input>
			<input name="B" type="float" storage="varying" multi="*" shader_parameter="1" value=".5" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
										</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.									</usage>
		</block>
		<block id="Divide" position_x="-0" position_y="7" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Displacement_Scale" output="value"/>
			</input>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="value">
				<connection parent="Length" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = A / B"/>
			<rsl_code>
		$(value) = $(A) / $(B);
													</rsl_code>
			<rsl_include/>
			<usage>Divides input A by input B.												</usage>
		</block>
		<block id="Dot" position_x="-3" position_y="4" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="vector(0)" description="1st Input">
				<connection parent="Normalize" output="value"/>
			</input>
			<input name="B" type="vector" storage="varying" value="vector(1)" description="2nd Input">
				<connection parent="Multiply" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = A . B"/>
			<rsl_code>
		$(value) = $(A).$(B);
																</rsl_code>
			<rsl_include/>
			<usage>Returns the dot product of two vectors, the sum of the products of each component of the two vectors.															</usage>
		</block>
		<block id="Flakes_Falloff" position_x="-0" position_y="4" author="rconstruct">
			<input name="x" type="float" storage="varying" value="0" description="value to test" type_parent="value">
				<connection parent="Dot" output="value"/>
			</input>
			<input name="minimum" type="float" storage="varying" value="0.15" description="position of bottom of step" type_parent="value"/>
			<input name="maximum" type="float" storage="varying" value=".85" description="position of top of step" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="value of smoothstep function at x"/>
			<rsl_code>
	#define stype_$(minimum:type) 1
	#if RENDERER == prman
		$(value) = smoothstep( $(minimum), $(maximum), $(x) );
	#else
		#ifdef stype_float
			$(value) = smoothstep( $(minimum), $(maximum), $(x) );
		#else
			$(value) = color(
			smoothstep(comp( $(minimum),0),comp( $(maximum),0),comp( $(x), 0)),
			smoothstep(comp( $(minimum),1),comp( $(maximum),1),comp( $(x), 1)),
			smoothstep(comp( $(minimum),2),comp( $(maximum),2),comp( $(x), 2)));
		#endif /* stype_$(minimum:type) */
	#endif /* RENDERER */
	#undef stype_$(minimum:type)
		
																</rsl_code>
			<rsl_include/>
			<usage>Result is zero if &quot;x&quot; is less than &quot;minimum&quot;, one if &quot;x&quot; is greater than &quot;maximum&quot;, otherwise it is interpolated between zero and one with a smooth Hermite curve. If the type is color, then it operates on a component basis.															</usage>
		</block>
		<block id="Fresnel" position_x="8" position_y="2" author="rconstruct">
			<input name="I" type="vector" storage="varying" value="normalize(I)" description="Incident vector"/>
			<input name="N" type="normal" storage="varying" value="normalize(N)" description="Surface normal"/>
			<input name="eta" type="float" storage="varying" value="0.75" description="The relative index of refraction"/>
			<output name="R" type="vector" storage="varying" description="The reflected vector"/>
			<output name="T" type="vector" storage="varying" description="The refracted vector"/>
			<output name="Kr" type="float" storage="varying" description="The reflected coefficient"/>
			<output name="Kt" type="float" storage="varying" description="The refracted coefficient"/>
			<rsl_code>
		/* initialize */
		$(Kr) = 0; $(Kt) = 0; $(R) = vector(0); $(T) = vector(0);
        fresnel( $(I), $(N), $(eta), $(Kr), $(Kt), $(R), $(T) );
				</rsl_code>
			<rsl_include/>
			<usage>Return the reflection coefficient Kr and the refraction (or transmission) coefficient &quot;Kt&quot;, given an incident direction &quot;I&quot;, the surface normal &quot;N&quot;, and the relative index of refraction &quot;eta&quot;. Eta is the ratio of the index of refraction in the volume containing the incident vector, to that of the volume being entered. These coefficients are computed using the Fresnel formula. This function also returns the reflected &quot;R&quot; and transmitted &quot;T&quot; vectors.			</usage>
		</block>
		<block id="I" position_x="-9" position_y="4" author="rconstruct">
			<output name="I" type="vector" storage="varying" description="Incident ray direction"/>
			<rsl_code>
	$(I) = I;
																</rsl_code>
			<rsl_include/>
			<usage>Incident ray direction. The availability of this global variable for the different shading contexts is renderer specific.															</usage>
		</block>
		<block id="Length" position_x="-3" position_y="7" author="rconstruct">
			<input name="Vin" type="normal" storage="varying" value="vector(1)" description="Input vector">
				<connection parent="Transform_2" output="Pout"/>
			</input>
			<output name="value" type="float" storage="varying" description="The lenght of the vector"/>
			<rsl_code>
		$(value) = length( $(Vin) );
													</rsl_code>
			<rsl_include/>
			<usage>Returns the length of a vector ( sqrt(Vin.Vin) ).												</usage>
		</block>
		<block id="Max" position_x="-3" position_y="3" author="rconstruct">
			<input name="A" type="float" storage="varying" value="0" description="1st input" type_parent="value">
				<connection parent="Dot" output="value"/>
			</input>
			<input name="B" type="float" storage="varying" multi="," value="0" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="out = the largest input"/>
			<rsl_code>
		$(value) = max( $(A), $(B) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns the maximum of the arguments given. When evaluating point type variables, the arguments will be evaluated on a component basis.															</usage>
		</block>
		<block id="Multiply" position_x="-6" position_y="3" author="rconstruct">
			<input name="A" type="vector" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Normalize_2" output="value"/>
			</input>
			<input name="B" type="vector" storage="varying" multi="*" value="-1" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="vector" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
																</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.															</usage>
		</block>
		<block id="Multiply_2" position_x="-7.54736842105263" position_y="-2.38947368421053" author="rconstruct">
			<input name="A" type="point" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Transform" output="Pout"/>
			</input>
			<input name="B" type="point" storage="varying" multi="*" value="4" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="point" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
																</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.															</usage>
		</block>
		<block id="Multiply_3" position_x="3" position_y="6" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Normalize" output="value"/>
			</input>
			<input name="B" type="normal" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="value">
				<connection parent="Divide" output="value"/>
			</input>
			<output name="value" type="normal" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
													</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.												</usage>
		</block>
		<block id="Multiply_5" position_x="-2" position_y="-3.34285714285714" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Voronoi3D2F" output="feature1"/>
			</input>
			<input name="B" type="float" storage="varying" multi="*" value=".25" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
										</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.									</usage>
		</block>
		<block id="Multiply_6" position_x="0" position_y="-8" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Cell3D" output="value"/>
			</input>
			<input name="B" type="float" storage="varying" multi="*" value="100000" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
				</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.			</usage>
		</block>
		<block id="Multiply_7" position_x="11" position_y="-3" author="rconstruct">
			<input name="A" type="color" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Subtract_4" output="value"/>
			</input>
			<input name="B" type="color" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="value">
				<connection parent="OrenNayar" output="Ci"/>
			</input>
			<output name="value" type="color" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
				</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.			</usage>
		</block>
		<block id="N" position_x="-9" position_y="5" author="rconstruct">
			<output name="N" type="normal" storage="varying" description="Surface shading normal"/>
			<rsl_code>
    $(N) = N;
    															</rsl_code>
			<rsl_include/>
			<usage>Surface shading normal. The availability of this global variable in the different shading contexts is renderer specific. It&apos;s not available in imager shaders.															</usage>
		</block>
		<block id="Normal2Vector" position_x="3" position_y="5" author="rconstruct">
			<input name="in" type="normal" storage="varying" value="normal(0)" description="Input value">
				<connection parent="Multiply_3" output="value"/>
			</input>
			<output name="value" type="vector" storage="varying" description="Output value"/>
			<rsl_code>
	    $(value) = vector( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
													</rsl_code>
			<rsl_include/>
			<usage>Sets a vector with a normal&apos;s components.												</usage>
		</block>
		<block id="Normalize" position_x="-6" position_y="5" author="rconstruct">
			<input name="Vin" type="normal" storage="varying" value="N" description="Input vector" type_parent="value">
				<connection parent="N" output="N"/>
			</input>
			<output name="value" type="normal" storage="varying" description="Output unit length vector"/>
			<rsl_code>
		$(value) = normalize( $(Vin) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns a unit vector in the direction of input vector (Vin/length(Vin)).															</usage>
		</block>
		<block id="Normalize_2" position_x="-6" position_y="4" author="rconstruct">
			<input name="Vin" type="vector" storage="varying" value="N" description="Input vector" type_parent="value">
				<connection parent="I" output="I"/>
			</input>
			<output name="value" type="vector" storage="varying" description="Output unit length vector"/>
			<rsl_code>
		$(value) = normalize( $(Vin) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns a unit vector in the direction of input vector (Vin/length(Vin)).															</usage>
		</block>
		<block id="Normalize_3" position_x="5" position_y="-0" author="rconstruct">
			<input name="Vin" type="normal" storage="varying" value="N" description="Input vector" type_parent="value">
				<connection parent="CalcNormal" output="N"/>
			</input>
			<output name="value" type="normal" storage="varying" description="Output unit length vector"/>
			<rsl_code>
		$(value) = normalize( $(Vin) );
													</rsl_code>
			<rsl_include/>
			<usage>Returns a unit vector in the direction of input vector (Vin/length(Vin)).												</usage>
		</block>
		<block id="OrenNayar" position_x="8" position_y="-2" author="rconstruct">
			<input name="Cdiff" type="color" storage="varying" value="color(.5)" description="Diffuse color">
				<connection parent="Clamp_3" output="value"/>
			</input>
			<input name="Kd" type="float" storage="varying" value="0.2" description="Diffuse light coefficient"/>
			<input name="roughness" type="float" storage="varying" value="0.05" description="roughness">
				<connection parent="Subtract_3" output="value"/>
			</input>
			<input name="qualitative" type="float" storage="uniform" value="1" description="Toggle qualitative or full model"/>
			<input name="N" type="normal" storage="varying" value="normalize(N)" description="Surface normal"/>
			<input name="I" type="vector" storage="varying" value="normalize(I)" description="Direction of viewer"/>
			<input name="category" type="string" storage="uniform" value="&quot;&quot;" description="Light categories accepted"/>
			<output name="Ci" type="color" storage="varying" description="Shaded color"/>
			<rsl_code>
	#define use_qualitative_$(qualitative)
		aov_surfacecolor = $(Cdiff);
	
	#ifdef use_qualitative_1
		/* Air&apos;s diffuse can take a roughness parameter, in which */
		/* case behaves as the Oren-Nayar (qualitative?) model */
		#if RENDERER == air
			aov_diffuse = $(Kd) * diffuse( $(N), $(roughness) );
		#else
			aov_diffuse = $(Kd) * OrenNayar(	$(roughness), $(N), $(I),
												$(category) );

        #if RENDERER == _3delight

            shader $(blockname)_gi_light = getshader(&quot;gi_light&quot;);

            if ($(blockname)_gi_light != null)
            {
                color gi = $(blockname)_gi_light-&gt;computeGI(
                    P,
                    $(N),
                    $(I),
                    $(roughness), 
                    $(Cdiff));
                
                aov_indirectdiffuse = gi;
            }

        #endif
        
		#endif /* RENDERER */

        $(Ci) = aov_surfacecolor * (aov_diffuse + aov_indirectdiffuse);
	#else
		aov_diffuse = $(Kd) * LG_OrenNayar( $(Cdiff), $(roughness), $(N),
												$(I), $(category) );

        #if RENDERER == _3delight

            shader $(blockname)_gi_light = getshader(&quot;gi_light&quot;);

            if ($(blockname)_gi_light != null)
            {
                color gi = $(blockname)_gi_light-&gt;computeGI(
                    P,
                    $(N),
                    $(I),
                    $(roughness), 
                    $(Cdiff));
                
                aov_indirectdiffuse = gi;
            }

        #endif

		$(Ci) = aov_diffuse + aov_surfacecolor * aov_indirectdiffuse;

	#endif /* use_qualitative_$(qualitative) */
	#undef use_qualitative_$(qualitative)
	
										</rsl_code>
			<rsl_include>rsl_shrimp_shadingmodels.h									</rsl_include>
			<usage>Oren-Nayar diffuse term. This block has both the &quot;qualitative&quot; model based on Szymon Rusinkiewicz&apos;s implementation, and the full model with inter-reflections, based on Larry Gritz&apos;s implementation, depending on the content of the qualitative variable in the block. The roughness parameter controls the standard deviation of angle orientations of the surface grooves, so when roughness = 0, the term is Lambertian. The diffuse color value is passed to the aov_surfacecolor, and the diffuse value to the aov_diffuse AOV presets, only for the qualitative model (see the header for the C3 coefficient and L1 and L2 variables). The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.									</usage>
		</block>
		<block id="Red_color" position_x="-6" position_y="-0" author="rconstruct">
			<input name="in" type="color" storage="varying" value="color(0.643137, 0.054902, 0.164706)" description="Input" type_parent="value"/>
			<output name="value" type="color" storage="varying" description="Output = Input"/>
			<rsl_code>
		$(value) = $(in);
																</rsl_code>
			<rsl_include/>
			<usage>Useful for supplying multiple inputs with the same value.															</usage>
		</block>
		<block id="Root block" position_x="16" position_y="-0" author="" root="RIB" AOV_preview="1">
			<rib_statements>Hider &quot;raytrace&quot; &quot;int jitter&quot; [1]

Option &quot;trace&quot; &quot;int maxdepth&quot; [10]
Option &quot;trace&quot; &quot;int diffuseraycache&quot; [1]

Attribute &quot;visibility&quot; &quot;int trace&quot; [1]
Attribute &quot;visibility&quot; &quot;int diffuse&quot; [1]
Attribute &quot;visibility&quot; &quot;int specular&quot; [1]
Attribute &quot;visibility&quot; &quot;int transmission&quot; [1]

Attribute &quot;shade&quot; &quot;string diffusehitmode&quot; [&quot;shader&quot;]
Attribute &quot;shade&quot; &quot;string specularhitmode&quot; [&quot;shader&quot;]
Attribute &quot;shade&quot; &quot;string transmissionhitmode&quot; [&quot;shader&quot;]

Attribute &quot;trace&quot; &quot;int diffusemaxdepth&quot; [4]
Attribute &quot;trace&quot; &quot;int specularmaxdepth&quot; [4]
Attribute &quot;trace&quot; &quot;int displacements&quot; [1]

Attribute &quot;displacementbound&quot; &quot;float sphere&quot; [2] &quot;string coordinatesystem&quot; &quot;surface&quot;
Attribute &quot;trace&quot; &quot;float inflategrids&quot; [0.25]

Attribute &quot;light&quot; &quot;string shadows&quot; [&quot;on&quot;]

Attribute &quot;user&quot; &quot;int lightsamples&quot; [16] # arealights
Attribute &quot;user&quot; &quot;int gi_light_samples&quot; [256] # GI

Option &quot;user&quot; &quot;string gi_light_envmap&quot; [&quot;/home/cgwork/OSS/HDRIs/Arches_E_PineTree_3k.hdr&quot;]

#Option &quot;user&quot; &quot;string gi_light_envmap&quot; [&quot;/home/cgwork/OSS/HDRIs/renosuburb01_sm.hdr&quot;]

Option &quot;user&quot; &quot;string gi_light_envspace&quot; [&quot;world&quot;]
			</rib_statements>
			<imager_statement/>
			<input name="Ci" type="color" storage="varying" shader_parameter="1" value="0" description="Incident ray colour">
				<connection parent="Add_2" output="value"/>
			</input>
			<input name="Oi" type="color" storage="varying" shader_parameter="1" value="1" description="Incident ray opacity"/>
			<input name="P" type="point" storage="varying" shader_parameter="1" value="P" description="Displaced surface position">
				<connection parent="Add" output="value"/>
			</input>
			<input name="N" type="normal" storage="varying" shader_parameter="1" value="N" description="Displaced surface shading normal">
				<connection parent="Normalize_3" output="value"/>
			</input>
			<input name="Cl" type="color" storage="varying" shader_parameter="1" value="0" description="Outgoing light ray colour">
				<connection parent="AmbientLight" output="Cl"/>
			</input>
			<input name="Ol" type="color" storage="varying" shader_parameter="1" value="1" description="Outgoing light ray opacity"/>
			<input name="Cv" type="color" storage="varying" shader_parameter="1" value="0" description="Attenuated ray colour"/>
			<input name="Ov" type="color" storage="varying" shader_parameter="1" value="1" description="Attenuated ray opacity"/>
			<input name="Cm" type="color" storage="varying" shader_parameter="1" value="0" description="Output pixel colour"/>
			<input name="Om" type="color" storage="varying" shader_parameter="1" value="1" description="Output pixel opacity"/>
			<input name="AOV" type="color" storage="varying" shader_parameter="1" value="1" description="AOV preview output"/>
			<rsl_code/>
			<rsl_include/>
			<usage/>
		</block>
		<block id="Round" position_x="-0" position_y="-7" author="rconstruct">
			<input name="x" type="float" storage="varying" value="1" description="Input value">
				<connection parent="Multiply_6" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="The integer closest to x"/>
			<rsl_code>
		$(value) = round( $(x) );
				</rsl_code>
			<rsl_include/>
			<usage>Returns the closest integer to the supplied parameter &quot;x&quot;.			</usage>
		</block>
		<block id="SetComp" position_x="1" position_y="-0" author="rconstruct">
			<input name="x" type="float" storage="varying" value="0" description="X component">
				<connection parent="Clamp" output="value"/>
			</input>
			<input name="y" type="float" storage="varying" value="0" description="Y component">
				<connection parent="Clamp" output="value"/>
			</input>
			<input name="z" type="float" storage="varying" value="0" description="Z component">
				<connection parent="Clamp" output="value"/>
			</input>
			<output name="value" type="color" storage="varying" description="Point, vector, or normal with the specified components"/>
			<rsl_code>
		$(value) = $(value:type) ( $(x), $(y), $(z) ); 
																</rsl_code>
			<rsl_include/>
			<usage>Sets the X, Y, and Z components of a point, vector, or normal.															</usage>
		</block>
		<block id="Spline" position_x="1" position_y="-2" author="rconstruct">
			<input name="basis" type="string" storage="uniform" value="&quot;bezier&quot;" description="The basis function"/>
			<input name="x" type="float" storage="varying" value="0" description="The value to test the spline at">
				<connection parent="Subtract_2" output="value"/>
			</input>
			<input name="point1" type="color" storage="varying" value="color(0.168627, 0.227451, 0.0823529)" description="The 1st Control Point" type_parent="value"/>
			<input name="point2" type="color" storage="varying" value="color(0.207843, 0.176471, 0.137255)" description="The 2nd Control Point" type_parent="value"/>
			<input name="point3" type="color" storage="varying" value="color(0.552941, 0.52549, 0.501961)" description="The 3rd Control Point" type_parent="value"/>
			<input name="point4" type="color" storage="varying" multi="," value="color(0.533333, 0.592157, 0.643137)" description="The 4th or subsequent Control Points" type_parent="value"/>
			<output name="value" type="color" storage="varying" description="The value of the spline at x"/>
			<rsl_code>
		$(value) = spline(	$(basis), $(x), $(point1), $(point2),
							$(point3), $(point4) );
				</rsl_code>
			<rsl_include/>
			<usage>Fits a spline into the control points passed, using the specified spline basis function. These can be of type &quot;catmull-rom&quot;, &quot;bezier&quot;, &quot;bspline&quot;, &quot;hermite&quot;, or &quot;linear&quot;. Defaults to &quot;catmull-rom&quot;. In 3delight, any spline type may be prefixed by &quot;solve&quot;, such as &quot;solvecatmull-rom&quot;, in which case this shadeop becomes a root solver and may be used as an invert function. The number of required data points is, for &quot;catmull-rom&quot;, 4 or higher; for &quot;bezier&quot;, 4n+3; for &quot;hermite&quot;, 4n+2; for &quot;bspline&quot; 4 or higher.			</usage>
		</block>
		<block id="Sqrt" position_x="-10" position_y="-6" author="rconstruct">
			<input name="x" type="float" storage="varying" value="1" description="Input value">
				<connection parent="Area" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = sqrt(x)"/>
			<rsl_code>
		$(value) = sqrt( $(x) );
							</rsl_code>
			<rsl_include/>
			<usage>Returns the square root of the argument						</usage>
		</block>
		<block id="Subtract" position_x="-2" position_y="-2" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Voronoi3D2F" output="feature2"/>
			</input>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="value">
				<connection parent="Multiply_5" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = A - B"/>
			<rsl_code>
		$(value) = $(A) - $(B);
																</rsl_code>
			<rsl_include/>
			<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.															</usage>
		</block>
		<block id="Subtract_2" position_x="-2" position_y="-5" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Voronoi3D2F" output="feature2"/>
			</input>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="value">
				<connection parent="Voronoi3D2F" output="feature1"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = A - B"/>
			<rsl_code>
		$(value) = $(A) - $(B);
							</rsl_code>
			<rsl_include/>
			<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.						</usage>
		</block>
		<block id="Subtract_3" position_x="3" position_y="-4" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value"/>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="value">
				<connection parent="Subtract_2" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = A - B"/>
			<rsl_code>
		$(value) = $(A) - $(B);
				</rsl_code>
			<rsl_include/>
			<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.			</usage>
		</block>
		<block id="Subtract_4" position_x="11" position_y="-2" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value"/>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="value">
				<connection parent="Clamp_2" output="value"/>
			</input>
			<output name="value" type="float" storage="varying" description="val = A - B"/>
			<rsl_code>
		$(value) = $(A) - $(B);
				</rsl_code>
			<rsl_include/>
			<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.			</usage>
		</block>
		<block id="Transform" position_x="-10" position_y="-2" author="rconstruct">
			<input name="P" type="point" storage="varying" value="P" description="Point, vector or normal to transform" type_parent="Pout">
				<connection parent="p" output="P"/>
			</input>
			<input name="from_space" type="string" storage="uniform" value="&quot;current&quot;" description="The coordinate system to transform from"/>
			<input name="to_space" type="string" storage="uniform" value="&quot;object&quot;" description="The coordinate system to transform into"/>
			<input name="Matrix" type="matrix" storage="varying" value="UND" description="Use this matrix instead of a predefined coordinate system"/>
			<output name="Pout" type="point" storage="varying" description="The transformed point, vector or normal"/>
			<rsl_code>
	#ifdef TRANSFORM_ARGUMENTS
	#undef TRANSFORM_ARGUMENTS
	#endif

	#define Matrix_$(Matrix)
	#ifdef Matrix_UND
		#define TRANSFORM_ARGUMENTS $(to_space)
	#else
		#define TRANSFORM_ARGUMENTS	$(Matrix)
	#endif /* Matrix_UND */

	#define $(blockname)_$(P:type) 1
	#ifdef $(blockname)_point
		$(Pout) = transform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#elif $(blockname)_vector
		$(Pout) = vtransform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#elif $(blockname)_normal
		$(Pout) = ntransform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#endif /* $(blockname)_$(P:type) */
	#undef $(blockname)_$(P:type)
	
	#undef Matrix_$(Matrix)
	#undef TRANSFORM_ARGUMENTS
																</rsl_code>
			<rsl_include>rsl_shrimp_helpers.h															</rsl_include>
			<usage>A block for the &quot;transform&quot;, &quot;vtransform&quot; and &quot;ntransform&quot; functions, to transform the supplied point &quot;P&quot;, vector &quot;V&quot; or normal &quot;N&quot; respectively, from the coordinate system &quot;fromspace&quot; to the coordinate system &quot;tospace&quot;, with &quot;fromspace&quot; defaulting to &quot;current&quot;. Note that &quot;current&quot; is implementation specific. Predefined coordinate systems are: &quot;current&quot;, &quot;object&quot;, &quot;shader&quot;, &quot;world&quot;, &quot;camera&quot;, &quot;screen&quot;, &quot;raster&quot; and &quot;NDC&quot;. A transformation matrix might be given instead of a &quot;tospace&quot; coordinate system. User defined coordinate systems can also be refered to.															</usage>
		</block>
		<block id="Transform_2" position_x="-6" position_y="7" author="rconstruct">
			<input name="P" type="normal" storage="varying" value="P" description="Point, vector or normal to transform" type_parent="Pout">
				<connection parent="Normalize" output="value"/>
			</input>
			<input name="from_space" type="string" storage="uniform" value="&quot;camera&quot;" description="The coordinate system to transform from"/>
			<input name="to_space" type="string" storage="uniform" value="&quot;shader&quot;" description="The coordinate system to transform into"/>
			<input name="Matrix" type="matrix" storage="varying" value="UND" description="Use this matrix instead of a predefined coordinate system"/>
			<output name="Pout" type="normal" storage="varying" description="The transformed point, vector or normal"/>
			<rsl_code>
	#ifdef TRANSFORM_ARGUMENTS
	#undef TRANSFORM_ARGUMENTS
	#endif

	#define Matrix_$(Matrix)
	#ifdef Matrix_UND
		#define TRANSFORM_ARGUMENTS $(to_space)
	#else
		#define TRANSFORM_ARGUMENTS	$(Matrix)
	#endif /* Matrix_UND */

	#define $(blockname)_$(P:type) 1
	#ifdef $(blockname)_point
		$(Pout) = transform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#elif $(blockname)_vector
		$(Pout) = vtransform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#elif $(blockname)_normal
		$(Pout) = ntransform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#endif /* $(blockname)_$(P:type) */
	#undef $(blockname)_$(P:type)
	
	#undef Matrix_$(Matrix)
	#undef TRANSFORM_ARGUMENTS
													</rsl_code>
			<rsl_include>rsl_shrimp_helpers.h												</rsl_include>
			<usage>A block for the &quot;transform&quot;, &quot;vtransform&quot; and &quot;ntransform&quot; functions, to transform the supplied point &quot;P&quot;, vector &quot;V&quot; or normal &quot;N&quot; respectively, from the coordinate system &quot;fromspace&quot; to the coordinate system &quot;tospace&quot;, with &quot;fromspace&quot; defaulting to &quot;current&quot;. Note that &quot;current&quot; is implementation specific. Predefined coordinate systems are: &quot;current&quot;, &quot;object&quot;, &quot;shader&quot;, &quot;world&quot;, &quot;camera&quot;, &quot;screen&quot;, &quot;raster&quot; and &quot;NDC&quot;. A transformation matrix might be given instead of a &quot;tospace&quot; coordinate system. User defined coordinate systems can also be refered to.												</usage>
		</block>
		<block id="Turbulence3D" position_x="-7" position_y="-4" author="rconstruct">
			<input name="P" type="point" storage="varying" value="P" description="Point to sample turbulence at">
				<connection parent="Transform" output="Pout"/>
			</input>
			<input name="filterwidth" type="float" storage="varying" value="0.25" description="Filter width for antialiasing">
				<connection parent="Sqrt" output="value"/>
			</input>
			<input name="octaves" type="float" storage="uniform" value="5" description="Maximum octaves of noise"/>
			<input name="lacunarity" type="float" storage="varying" value="2.17" description="Gap in successive frequencies"/>
			<input name="gain" type="float" storage="varying" value=".55" description="Controls the contrast of the turbulence"/>
			<input name="amplitude" type="float" storage="varying" value="2" description="Amplitude of turbulence"/>
			<output name="value" type="float" storage="varying" description="Turbulence value at p"/>
			<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * turbulence( $(P), $(filterwidth), $(octaves),
					$(lacunarity), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector vturbulence( $(P),
					$(filterwidth), $(octaves), $(lacunarity), $(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)
																</rsl_code>
			<rsl_include>rsl_shrimp_fractal.h															</rsl_include>
			<usage>3 dimensional turbulence fractal function with Perlin noise basis. Returns a result in the [0,1] range by default.															</usage>
		</block>
		<block id="Two_Tone_Blend" position_x="-3" position_y="-0" author="rconstruct">
			<input name="weight" type="float" storage="varying" value="0.5" description="The mixing factor">
				<connection parent="Blend_Ratio" output="power"/>
			</input>
			<input name="A" type="color" storage="varying" value="0" description="1st Input" type_parent="value">
				<connection parent="Red_color" output="value"/>
			</input>
			<input name="B" type="color" storage="varying" value="1" description="2nd Input" type_parent="value">
				<connection parent="Yellow_color" output="value"/>
			</input>
			<output name="value" type="color" storage="varying" description="The resulting mix between A and B"/>
			<rsl_code>
		$(value) = mix( $(A), $(B), $(weight) );
																</rsl_code>
			<rsl_include/>
			<usage>Mix returns x*(1-a)+y*a, that is, it performs a linear blend between values A and B. The types of A and B must be identical, but may be any of float, point, vector, normal, or color. The variants that operate on colors or point-like objects operate on a component by component basis (e.g: separately for x, y, and z).															</usage>
		</block>
		<block id="VaryEach" position_x="3" position_y="-7" author="rconstruct">
			<input name="Cin" type="color" storage="varying" value="color(0.5)" description="Input color">
				<connection parent="Spline" output="value"/>
			</input>
			<input name="index" type="float" storage="varying" value="1" description="Index">
				<connection parent="Round" output="value"/>
			</input>
			<input name="varyhue" type="float" storage="varying" value=".1" description="Hue variation"/>
			<input name="varysat" type="float" storage="varying" value=".2" description="Saturation variation"/>
			<input name="varylum" type="float" storage="varying" value=".4" description="Luminance variation"/>
			<output name="value" type="color" storage="varying" description="The resulting color"/>
			<rsl_code>
		$(value) = varyEach(	$(Cin), $(index), $(varyhue),
							$(varysat), $(varylum) );
				</rsl_code>
			<rsl_include>rsl_shrimp_helpers.h			</rsl_include>
			<usage>Larry Gritz&apos;s VaryEach takes a computed color, then tweaks each indexed item separately to add some variation. Hue, saturation and lightness are all independently controlled. Hue adds, but saturation and lightness multiply.			</usage>
		</block>
		<block id="Voronoi3D2F" position_x="-5" position_y="-2" author="rconstruct">
			<input name="P" type="point" storage="varying" value="P" description="Point to sample Voronoi at">
				<connection parent="Transform" output="Pout"/>
			</input>
			<input name="jittering" type="float" storage="varying" value="2" description="Jitter">
				<connection parent="Turbulence3D" output="value"/>
			</input>
			<input name="metric" type="float" storage="uniform" value="3" description="Distanc metric, see help"/>
			<output name="feature1" type="float" storage="varying" description="Feature 1"/>
			<output name="feature2" type="float" storage="varying" description="Feature 2"/>
			<output name="Ppos1" type="point" storage="varying" description="Position 1"/>
			<output name="Ppos2" type="point" storage="varying" description="Position 2"/>
			<rsl_code>
		/* initialize */
		$(feature1) = 0; $(Ppos1) = point(0);
		$(feature2) = 0; $(Ppos2) = point(0);
		voronoi_f1f2_3d( $(P), $(jittering), $(metric), $(feature1),
					$(feature2), $(Ppos1), $(Ppos2) );
																</rsl_code>
			<rsl_include>rsl_shrimp_fractal.h															</rsl_include>
			<usage>3D Voronoi cell noise, 2 features version. When &quot;metric&quot; = 0, distance metric is Tchebychev otherwise the distance metric = Minkowski, being &quot;metric&quot;, Minkowski&apos;s P parameter, with P = 1 as the Manhattan metric, P = 2, the Euclidian metric, and allowing higher orders of P. Note that as P increases, it tends towards the Tchebychev result.															</usage>
		</block>
		<block id="Yellow_color" position_x="-6" position_y="-1" author="rconstruct">
			<input name="in" type="color" storage="varying" value="color(1, 0.721569, 0.0196078)" description="Input"/>
			<output name="value" type="color" storage="varying" description="Output = Input"/>
			<rsl_code>
		$(value) = $(in);
																</rsl_code>
			<rsl_include/>
			<usage>Useful for supplying multiple inputs with the same value.															</usage>
		</block>
		<block id="p" position_x="-10" position_y="-1" author="rconstruct">
			<output name="P" type="point" storage="varying" description="Surface position"/>
			<rsl_code>
    $(P) = P;
    															</rsl_code>
			<rsl_include/>
			<usage>Note that in all shading contexts, &quot;P&quot; is the surface position, the only exception being volume shaders, in which &quot;P&quot; is the light ray origin. Also note that in imager shaders, &quot;P&quot; is the position of the pixel center in raster space, with the z coordinate being 0.															</usage>
		</block>
	</network>
</shrimp>
