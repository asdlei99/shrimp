<shrimp name="new_scene">
	<about/>
	<network>
		<block id="CalcNormal" position_x="4" position_y="1" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="Point to calculate normal at">
				<connection parent="Subtract" output="val"/>
			</input>
			<output name="NN" type="normal" storage="varying" description="NN is normal at p"/>
			<rsl_code>
	$(NN) = calculatenormal( $(p) );
							</rsl_code>
			<rsl_include/>
			<usage>Returns the surface normal of the given point on the surface (Du(P)^Dv(P)). You should always recalculate the normals after a displacement.						</usage>
		</block>
		<block id="Km" position_x="0" position_y="-3" author="rconstruct">
			<input name="in" type="float" storage="uniform" shader_parameter="1" value=".1" description="Input" type_parent="out"/>
			<output name="out" type="float" storage="varying" description="Output = Input"/>
			<rsl_code>
	$(out) = $(in);
							</rsl_code>
			<rsl_include/>
			<usage>Useful for supplying multiple inputs with the same value.						</usage>
		</block>
		<block id="Multiply" position_x="0" position_y="-2" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="Normalize" output="val"/>
			</input>
			<input name="B" type="normal" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="val">
				<connection parent="Subtract_2" output="val"/>
			</input>
			<output name="val" type="normal" storage="varying" description="val = A * B"/>
			<rsl_code>
	$(val) = $(A) * $(B);
							</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.
							</usage>
		</block>
		<block id="Multiply_2" position_x="2" position_y="-2" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="Multiply" output="val"/>
			</input>
			<input name="B" type="normal" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="val">
				<connection parent="Km" output="out"/>
			</input>
			<output name="val" type="normal" storage="varying" description="val = A * B"/>
			<rsl_code>
	$(val) = $(A) * $(B);
							</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.
							</usage>
		</block>
		<block id="N" position_x="-4" position_y="-1" author="rconstruct">
			<output name="N" type="normal" storage="varying" description="Surface shading normal"/>
			<rsl_code>
    $(N) = N;
    						</rsl_code>
			<rsl_include/>
			<usage/>
		</block>
		<block id="Normal2Point" position_x="2" position_y="-1" author="rconstruct">
			<input name="in" type="normal" storage="varying" value="0" description="Input value">
				<connection parent="Multiply_2" output="val"/>
			</input>
			<output name="out" type="point" storage="varying" description="Output value"/>
			<rsl_code>
	    $(out) = point( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
							</rsl_code>
			<rsl_include/>
			<usage/>
		</block>
		<block id="Normalize" position_x="-4" position_y="-2" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="1" description="Input" type_parent="val">
				<connection parent="N" output="N"/>
			</input>
			<output name="val" type="normal" storage="varying" description="val is a vector of unit length"/>
			<rsl_code>
	$(val) = normalize( $(A) );
							</rsl_code>
			<rsl_include/>
			<usage>Returns a unit vector in the direction of input vector (V/length(V)).						</usage>
		</block>
		<block id="Ridged3D" position_x="-2" position_y="1" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="point to sample fractal at">
				<connection parent="Transform" output="pp"/>
			</input>
			<input name="fwidth" type="float" storage="varying" value="0" description="Filter width for antialiasing"/>
			<input name="octaves" type="float" storage="uniform" value="5" description="Maximum octaves of noise"/>
			<input name="lacunarity" type="float" storage="uniform" value="2.17" description="Controls the smoothness of the fractal"/>
			<input name="gain" type="float" storage="uniform" value="0.5" description="Controls the contrast of the fractal"/>
			<input name="offset" type="float" storage="uniform" value="0.7" description="Controls the multifractality"/>
			<input name="amplitude" type="float" storage="varying" value="1" description="Amplitude of fractal"/>
			<output name="val" type="float" storage="varying" description="fractal value at p"/>
			<rsl_code>
	#define $(val)_$(val:type)
	#ifdef $(val)_float
		$(val) = $(amplitude) * Ridged( $(p), $(fwidth), $(octaves),
						$(lacunarity), $(offset), $(gain) );
	#else
		$(val) = $(amplitude) * $(val:type) (vector vRidged( $(p), $(fwidth),
					$(octaves), $(lacunarity), $(offset), $(gain) ) );
	#endif
							</rsl_code>
			<rsl_include>shrimp_fractal.h						</rsl_include>
			<usage>This is Ken Musgrave&apos;s Ridged Multi-fractal function. Note that offset can change the scale of the output drastically.
							</usage>
		</block>
		<block id="Root block" position_x="6" position_y="2" author="" root="RIB" AOV_preview="1">
			<rib_statements/>
			<imager_statement/>
			<input name="Ci" type="color" storage="varying" shader_parameter="1" value="0" description="Incident ray colour">
				<connection parent="SCurve" output="val"/>
			</input>
			<input name="Oi" type="color" storage="varying" shader_parameter="1" value="1" description="Incident ray opacity"/>
			<input name="P" type="point" storage="varying" shader_parameter="1" value="P" description="Displaced surface position">
				<connection parent="Subtract" output="val"/>
			</input>
			<input name="N" type="normal" storage="varying" shader_parameter="1" value="N" description="Displaced surface shading normal">
				<connection parent="CalcNormal" output="NN"/>
			</input>
			<input name="Cl" type="color" storage="varying" shader_parameter="1" value="0" description="Outgoing light ray colour"/>
			<input name="Ol" type="color" storage="varying" shader_parameter="1" value="1" description="Outgoing light ray opacity"/>
			<input name="Cv" type="color" storage="varying" shader_parameter="1" value="0" description="Attenuated ray colour"/>
			<input name="Ov" type="color" storage="varying" shader_parameter="1" value="1" description="Attenuated ray opacity"/>
			<input name="Cm" type="color" storage="varying" shader_parameter="1" value="0" description="Output pixel colour"/>
			<input name="Om" type="color" storage="varying" shader_parameter="1" value="1" description="Output pixel opacity"/>
			<input name="AOV" type="color" storage="varying" shader_parameter="1" value="1" description="AOV preview output"/>
			<rsl_code/>
			<rsl_include/>
			<usage/>
		</block>
		<block id="SCurve" position_x="4" position_y="4" author="rconstruct">
			<input name="ctype" type="string" storage="uniform" value="&quot;mean&quot;" description="Curvature type, see usage."/>
			<input name="cmin" type="float" storage="varying" value="-1" description="Minimum"/>
			<input name="cmax" type="float" storage="varying" value="1" description="Maximum"/>
			<input name="greys" type="float" storage="varying" value="0" description="Greyscale on/off"/>
			<input name="Nn" type="vector" storage="varying" value="normalize(N)" description="Surface normal"/>
			<input name="I" type="vector" storage="varying" value="normalize(I)" description="Direction of viewer"/>
			<output name="val" type="color" storage="varying" description="Curvature output"/>
			<rsl_code>
        $(val) = scurvature( $(ctype), $(cmin), $(cmax), $(greys), $(Nn), $(I));
				</rsl_code>
			<rsl_include>shrimp_helpers.h			</rsl_include>
			<usage>Surface curvature block, based on Mario Marengo&apos;s VEX work. Curvature types are gauss, mean, amean, min, max. If greyscale = 1.0, then it returns the curvature intensity in greyscale, else, it returns it in color.			</usage>
		</block>
		<block id="Subtract" position_x="2" position_y="2" author="rconstruct">
			<input name="A" type="point" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="p" output="P"/>
			</input>
			<input name="B" type="point" storage="varying" value="1" description="2nd input" type_parent="val">
				<connection parent="Normal2Point" output="out"/>
			</input>
			<output name="val" type="point" storage="varying" description="val = A - B"/>
			<rsl_code>
	$(val) = $(A) - $(B);
							</rsl_code>
			<rsl_include/>
			<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.						</usage>
		</block>
		<block id="Subtract_2" position_x="0" position_y="1" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="val"/>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="val">
				<connection parent="Ridged3D" output="val"/>
			</input>
			<output name="val" type="float" storage="varying" description="val = A - B"/>
			<rsl_code>
	$(val) = $(A) - $(B);
							</rsl_code>
			<rsl_include/>
			<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.						</usage>
		</block>
		<block id="Transform" position_x="-4" position_y="1" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="Point, vector or normal to transform" type_parent="pp">
				<connection parent="p" output="P"/>
			</input>
			<input name="from_space" type="string" storage="uniform" value="&quot;camera&quot;" description="The coordinate system to transform from"/>
			<input name="to_space" type="string" storage="uniform" value="&quot;shader&quot;" description="The coordinate system to transform into"/>
			<input name="mmat" type="matrix" storage="varying" value="none" description="Use this matrix instead of a predefined coordinate system"/>
			<output name="pp" type="point" storage="varying" description="The transformed point, vector or normal"/>
			<rsl_code>
	#define $(p)_$(p:type)
	#define mmat_$(mmat)
	
	#ifdef $(p)_point
	#ifdef mmat_none
		$(pp) = transform( $(from_space), $(to_space), $(p) );
	#else
		$(pp) = transform( $(from_space), $(mmat), $(p) );
	#endif
	#endif
	
	#ifdef $(p)_vector
	#ifdef mmat_none
		$(pp) = vtransform( $(from_space), $(to_space), $(p) );
	#else
		$(pp) = vtransform( $(from_space), $(mmat), $(p) );
	#endif
	#endif
	
	#ifdef $(p)_normal
	#ifdef mmat_none
		$(pp) = ntransform( $(from_space), $(to_space), $(p) );
	#else
		$(pp) = ntransform( $(from_space), $(mmat), $(p) );
	#endif
	#endif
							</rsl_code>
			<rsl_include/>
			<usage>The transform function transforms the point P (or vector V, or normal N, invoking vtransform and ntransform accordingly), from the coordinate system fromspace to the cordinate system tospace.. If fromspace isn&apos;t passed, then it assumes it to be the current coordinate system. Coordinate systems are, raster, screen, camera, world, and object. A shader knows also, the shader (the object coordinate system when the object was defined), current (world or camera), and custom coordinate systems. A transformation matrix might be given as a destination coordinate system.						</usage>
		</block>
		<block id="p" position_x="-4" position_y="2" author="rconstruct">
			<output name="P" type="point" storage="varying" description="Surface position"/>
			<rsl_code>
    $(P) = P;
    						</rsl_code>
			<rsl_include/>
			<usage>Note that in all shaders types, P is the surface position, the only exception being volume shaders, in which P is the light ray origin. Also note that in imager shaders, P is the position of the pixel center in raster space, with the z coordinate being 0.						</usage>
		</block>
	</network>
</shrimp>
