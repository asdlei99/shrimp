<shrimp name="new_scene" authors="">
	<about/>
	<network>
		<block id="Add" position_x="2" position_y="-4" author="rconstruct">
			<input name="A" type="point" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="p" output="P"/>
			</input>
			<input name="B" type="vector" storage="varying" multi="+" value="1" description="2nd or subsequent inputs" type_parent="val">
				<connection parent="Multiply" output="value"/>
			</input>
			<output name="val" type="point" storage="varying" description="val = A + B"/>
			<rsl_code>
		$(val) = $(A) + $(B);
																</rsl_code>
			<rsl_include/>
			<usage>Adds 2 or more inputs. All the input pads will inherit the type of the output pad.															</usage>
		</block>
		<block id="AmbientLight" position_x="9" position_y="-4" author="rconstruct">
			<input name="intensity" type="float" storage="varying" value="1" description="Light intensity"/>
			<input name="lightcolor" type="color" storage="varying" value="color( 1, .93, .81 )" description="Light color"/>
			<input name="category" type="string" storage="uniform" value="&quot;&quot;" description="Light category"/>
			<output name="Cl" type="color" storage="varying" description="Light ray color"/>
			<rsl_code>
		__category = $(category);
		$(Cl) = $(intensity) * $(lightcolor);
		L = vector(0);
				</rsl_code>
			<rsl_include/>
			<usage>Ambient light shader.			</usage>
		</block>
		<block id="CalcNormal" position_x="5" position_y="-2" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="Point to calculate normal at">
				<connection parent="Add" output="val"/>
			</input>
			<output name="NN" type="normal" storage="varying" description="NN is normal at p"/>
			<rsl_code>
		$(NN) = calculatenormal( $(p) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns the surface normal of the given point on the surface. You should always recalculate the normals after a displacement.															</usage>
		</block>
		<block id="Clamp" position_x="2" position_y="4" author="rconstruct">
			<input name="x" type="float" storage="varying" value="1" description="Input value" type_parent="value">
				<connection parent="Multiply_2" output="value"/>
			</input>
			<input name="minimum" type="float" storage="varying" value="0.0" description="minimum value" type_parent="value"/>
			<input name="maximum" type="float" storage="varying" value="1.0" description="maximum value" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="Clamp a between min and max"/>
			<rsl_code>
		$(value) = clamp( $(x), $(minimum), $(maximum) );
										</rsl_code>
			<rsl_include/>
			<usage>Clamps the first argument between the minimum and maximum values provided.									</usage>
		</block>
		<block id="Divide" position_x="0" position_y="-2" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="Ridged3D" output="val"/>
			</input>
			<input name="B" type="float" storage="varying" value="1" description="2nd input" type_parent="val">
				<connection parent="Length" output="val"/>
			</input>
			<output name="val" type="float" storage="varying" description="val = A / B"/>
			<rsl_code>
		$(val) = $(A) / $(B);
																</rsl_code>
			<rsl_include/>
			<usage>Divides input A by input B.															</usage>
		</block>
		<block id="Length" position_x="-2" position_y="-1" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="vector(1)" description="Input vector">
				<connection parent="Transform" output="pp"/>
			</input>
			<output name="val" type="float" storage="varying" description="The lenght of the vector"/>
			<rsl_code>
		$(val) = length( $(A) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns the length of a vector ( sqrt(V.V) ).															</usage>
		</block>
		<block id="Multiply" position_x="2" position_y="-1" author="rconstruct">
			<input name="A" type="vector" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Normal2Vector" output="value"/>
			</input>
			<input name="B" type="float" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="value">
				<connection parent="Divide" output="val"/>
			</input>
			<output name="value" type="vector" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
				</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.			</usage>
		</block>
		<block id="Multiply_2" position_x="2" position_y="2" author="rconstruct">
			<input name="A" type="float" storage="varying" value="1" description="1st input" type_parent="value">
				<connection parent="Divide" output="val"/>
			</input>
			<input name="B" type="float" storage="varying" multi="*" value="5" description="2nd or subsequent inputs" type_parent="value"/>
			<output name="value" type="float" storage="varying" description="val = A * B"/>
			<rsl_code>
		$(value) = $(A) * $(B);
										</rsl_code>
			<rsl_include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.									</usage>
		</block>
		<block id="N" position_x="-4" position_y="1" author="rconstruct">
			<output name="N" type="normal" storage="varying" description="Surface shading normal"/>
			<rsl_code>
    $(N) = N;
    															</rsl_code>
			<rsl_include/>
			<usage>Surface shading normal. The availability of this global variable in the different shading contexts is renderer specific. It&apos;s not available in imager shaders.															</usage>
		</block>
		<block id="Normal2Vector" position_x="2" position_y="-0" author="rconstruct">
			<input name="in" type="normal" storage="varying" value="normal(0)" description="Input value">
				<connection parent="Normalize" output="val"/>
			</input>
			<output name="value" type="vector" storage="varying" description="Output value"/>
			<rsl_code>
	    $(value) = vector( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
				</rsl_code>
			<rsl_include/>
			<usage>Sets a vector with a normal&apos;s components.			</usage>
		</block>
		<block id="Normalize" position_x="-4" position_y="-0" author="rconstruct">
			<input name="A" type="normal" storage="varying" value="N" description="Input vector" type_parent="val">
				<connection parent="N" output="N"/>
			</input>
			<output name="val" type="normal" storage="varying" description="Output unit length vector"/>
			<rsl_code>
		$(val) = normalize( $(A) );
																</rsl_code>
			<rsl_include/>
			<usage>Returns a unit vector in the direction of input vector (V/length(V)).															</usage>
		</block>
		<block id="OrenNayar" position_x="8" position_y="3" author="rconstruct">
			<input name="Cdiff" type="color" storage="varying" value="color(.5)" description="Diffuse color">
				<connection parent="Spline" output="value"/>
			</input>
			<input name="Kd" type="float" storage="varying" value="1" description="Diffuse light coefficient"/>
			<input name="roughness" type="float" storage="varying" value="0.05" description="roughness">
				<connection parent="Clamp" output="value"/>
			</input>
			<input name="qualitative" type="float" storage="uniform" value="1" description="Toggle qualitative or full model"/>
			<input name="N" type="normal" storage="varying" value="normalize(N)" description="Surface normal"/>
			<input name="I" type="vector" storage="varying" value="normalize(I)" description="Direction of viewer"/>
			<input name="category" type="string" storage="uniform" value="&quot;&quot;" description="Light categories accepted"/>
			<output name="Ci" type="color" storage="varying" description="Shaded color"/>
			<rsl_code>
	#define use_qualitative_$(qualitative)
		aov_surfacecolor = $(Cdiff);
	
	#ifdef use_qualitative_1
		/* Air&apos;s diffuse can take a roughness parameter, in which */
		/* case behaves as the Oren-Nayar (qualitative?) model */
		#if RENDERER == air
			aov_diffuse = $(Kd) * diffuse( $(N), $(roughness) );
		#else
			aov_diffuse = $(Kd) * OrenNayar(	$(roughness), $(N), $(I),
												$(category) );

        #if RENDERER == _3delight

            shader $(blockname)_gi_light = getshader(&quot;gi_light&quot;);

            if ($(blockname)_gi_light != null)
            {
                color gi = $(blockname)_gi_light-&gt;computeGI(
                    P,
                    $(N),
                    $(I),
                    $(roughness), 
                    $(Cdiff));
                
                aov_indirectdiffuse = gi;
            }

        #endif
        
		#endif /* RENDERER */

        $(Ci) = aov_surfacecolor * (aov_diffuse + aov_indirectdiffuse);
	#else
		aov_diffuse = $(Kd) * LG_OrenNayar( $(Cdiff), $(roughness), $(N),
												$(I), $(category) );

        #if RENDERER == _3delight

            shader $(blockname)_gi_light = getshader(&quot;gi_light&quot;);

            if ($(blockname)_gi_light != null)
            {
                color gi = $(blockname)_gi_light-&gt;computeGI(
                    P,
                    $(N),
                    $(I),
                    $(roughness), 
                    $(Cdiff));
                
                aov_indirectdiffuse = gi;
            }

        #endif

		$(Ci) = aov_diffuse + aov_surfacecolor * aov_indirectdiffuse;

	#endif /* use_qualitative_$(qualitative) */
	#undef use_qualitative_$(qualitative)
	
										</rsl_code>
			<rsl_include>rsl_shrimp_shadingmodels.h									</rsl_include>
			<usage>Oren-Nayar diffuse term. This block has both the &quot;qualitative&quot; model based on Szymon Rusinkiewicz&apos;s implementation, and the full model with inter-reflections, based on Larry Gritz&apos;s implementation, depending on the content of the qualitative variable in the block. The roughness parameter controls the standard deviation of angle orientations of the surface grooves, so when roughness = 0, the term is Lambertian. The diffuse color value is passed to the aov_surfacecolor, and the diffuse value to the aov_diffuse AOV presets, only for the qualitative model (see the header for the C3 coefficient and L1 and L2 variables). The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.									</usage>
		</block>
		<block id="Ridged3D" position_x="-2" position_y="-2" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="point to sample fractal at">
				<connection parent="Transform_2" output="pp"/>
			</input>
			<input name="fwidth" type="float" storage="varying" value="0" description="Filter width for antialiasing"/>
			<input name="octaves" type="float" storage="uniform" value="6" description="Maximum octaves of noise"/>
			<input name="lacunarity" type="float" storage="uniform" value="3" description="Gap between successive frequencies"/>
			<input name="gain" type="float" storage="uniform" value="0.5" description="Controls the contrast of the fractal"/>
			<input name="offset" type="float" storage="uniform" value=".8" description="Controls the multifractality"/>
			<input name="amplitude" type="float" storage="varying" shader_parameter="1" value=".2" description="Amplitude of fractal"/>
			<output name="val" type="float" storage="varying" description="fractal value at p"/>
			<rsl_code>
	#define $(blockname)_$(val:type)
	#ifdef $(blockname)_float
		$(val) = $(amplitude) * Ridged( $(p), $(fwidth), $(octaves),
						$(lacunarity), $(offset), $(gain) );
	#else
		$(val) = $(amplitude) * $(val:type) (vector vRidged( $(p), $(fwidth),
					$(octaves), $(lacunarity), $(offset), $(gain) ) );
	#endif
	#undef $(blockname)_$(val:type)
																</rsl_code>
			<rsl_include>rsl_shrimp_fractal.h															</rsl_include>
			<usage>Ken Musgrave&apos;s 3 dimensional Ridged Multifractal function. Note that offset can change the scale of the output drastically.															</usage>
		</block>
		<block id="Root block" position_x="12" position_y="-1" author="" root="RIB" AOV_preview="1">
			<rib_statements>Hider &quot;raytrace&quot; &quot;int jitter&quot; [1]

Option &quot;trace&quot; &quot;int maxdepth&quot; [10]
Option &quot;trace&quot; &quot;int diffuseraycache&quot; [1]

Attribute &quot;visibility&quot; &quot;int trace&quot; [1]
Attribute &quot;visibility&quot; &quot;int diffuse&quot; [1]
Attribute &quot;visibility&quot; &quot;int specular&quot; [1]
Attribute &quot;visibility&quot; &quot;int transmission&quot; [1]

Attribute &quot;shade&quot; &quot;string diffusehitmode&quot; [&quot;shader&quot;]
Attribute &quot;shade&quot; &quot;string specularhitmode&quot; [&quot;shader&quot;]
Attribute &quot;shade&quot; &quot;string transmissionhitmode&quot; [&quot;shader&quot;]

Attribute &quot;trace&quot; &quot;int diffusemaxdepth&quot; [4]
Attribute &quot;trace&quot; &quot;int specularmaxdepth&quot; [4]
Attribute &quot;trace&quot; &quot;int displacements&quot; [1]

Attribute &quot;displacementbound&quot; &quot;float sphere&quot; [1] &quot;string coordinatesystem&quot; &quot;shader&quot;

Attribute &quot;light&quot; &quot;string shadows&quot; [&quot;on&quot;]

Attribute &quot;user&quot; &quot;int lightsamples&quot; [16] # arealights
Attribute &quot;user&quot; &quot;int gi_light_samples&quot; [128] # GI
			</rib_statements>
			<imager_statement/>
			<input name="Ci" type="color" storage="varying" shader_parameter="1" value="0" description="Incident ray colour">
				<connection parent="OrenNayar" output="Ci"/>
			</input>
			<input name="Oi" type="color" storage="varying" shader_parameter="1" value="1" description="Incident ray opacity"/>
			<input name="P" type="point" storage="varying" shader_parameter="1" value="P" description="Displaced surface position">
				<connection parent="Add" output="val"/>
			</input>
			<input name="N" type="normal" storage="varying" shader_parameter="1" value="N" description="Displaced surface shading normal">
				<connection parent="CalcNormal" output="NN"/>
			</input>
			<input name="Cl" type="color" storage="varying" shader_parameter="1" value="0" description="Outgoing light ray colour">
				<connection parent="AmbientLight" output="Cl"/>
			</input>
			<input name="Ol" type="color" storage="varying" shader_parameter="1" value="1" description="Outgoing light ray opacity"/>
			<input name="Cv" type="color" storage="varying" shader_parameter="1" value="0" description="Attenuated ray colour"/>
			<input name="Ov" type="color" storage="varying" shader_parameter="1" value="1" description="Attenuated ray opacity"/>
			<input name="Cm" type="color" storage="varying" shader_parameter="1" value="0" description="Output pixel colour"/>
			<input name="Om" type="color" storage="varying" shader_parameter="1" value="1" description="Output pixel opacity"/>
			<input name="AOV" type="color" storage="varying" shader_parameter="1" value="1" description="AOV preview output"/>
			<rsl_code/>
			<rsl_include/>
			<usage/>
		</block>
		<block id="Spline" position_x="5" position_y="5" author="rconstruct">
			<input name="basis" type="string" storage="uniform" value="&quot;bezier&quot;" description="The basis function"/>
			<input name="x" type="float" storage="varying" value="0" description="The value to test the spline at">
				<connection parent="Clamp" output="value"/>
			</input>
			<input name="point1" type="color" storage="varying" value="color(0.384314, 0.211765, 0.176471)" description="The 1st Control Point" type_parent="value"/>
			<input name="point2" type="color" storage="varying" value="color(0.392157, 0.298039, 0.145098)" description="The 2nd Control Point" type_parent="value"/>
			<input name="point3" type="color" storage="varying" value="color(0.647059, 0.482353, 0.14902)" description="The 3rd Control Point" type_parent="value"/>
			<input name="point4" type="color" storage="varying" multi="," value="color(0.643137, 0.596078, 0.498039)" description="The 4th or subsequent Control Points" type_parent="value"/>
			<output name="value" type="color" storage="varying" description="The value of the spline at x"/>
			<rsl_code>
		$(value) = spline(	$(basis), $(x), $(point1), $(point2),
							$(point3), $(point4) );
										</rsl_code>
			<rsl_include/>
			<usage>Fits a spline into the control points passed, using the specified spline basis function. These can be of type &quot;catmull-rom&quot;, &quot;bezier&quot;, &quot;bspline&quot;, &quot;hermite&quot;, or &quot;linear&quot;. Defaults to &quot;catmull-rom&quot;. In 3delight, any spline type may be prefixed by &quot;solve&quot;, such as &quot;solvecatmull-rom&quot;, in which case this shadeop becomes a root solver and may be used as an invert function. The number of required data points is, for &quot;catmull-rom&quot;, 4 or higher; for &quot;bezier&quot;, 4n+3; for &quot;hermite&quot;, 4n+2; for &quot;bspline&quot; 4 or higher.									</usage>
		</block>
		<block id="Transform" position_x="-4" position_y="-1" author="rconstruct">
			<input name="p" type="normal" storage="varying" value="P" description="Point, vector or normal to transform" type_parent="pp">
				<connection parent="Normalize" output="val"/>
			</input>
			<input name="from_space" type="string" storage="uniform" value="&quot;camera&quot;" description="The coordinate system to transform from"/>
			<input name="to_space" type="string" storage="uniform" value="&quot;shader&quot;" description="The coordinate system to transform into"/>
			<input name="mmat" type="matrix" storage="varying" value="UND" description="Use this matrix instead of a predefined coordinate system"/>
			<output name="pp" type="normal" storage="varying" description="The transformed point, vector or normal"/>
			<rsl_code>
	#ifdef TRANSFORM_ARGUMENTS
	#undef TRANSFORM_ARGUMENTS
	#endif

	#define mmat_$(mmat)
	#ifdef mmat_UND
		#define TRANSFORM_ARGUMENTS $(to_space)
	#else
		#define TRANSFORM_ARGUMENTS	$(mmat)
	#endif /* mmat_UND */

	#define $(blockname)_$(p:type) 1
	#ifdef $(blockname)_point
		$(pp) = transform( $(from_space), TRANSFORM_ARGUMENTS , $(p) );
	#elif $(blockname)_vector
		$(pp) = vtransform( $(from_space), TRANSFORM_ARGUMENTS , $(p) );
	#elif $(blockname)_normal
		$(pp) = ntransform( $(from_space), TRANSFORM_ARGUMENTS , $(p) );
	#endif /* $(blockname)_$(p:type) */
	#undef $(blockname)_$(p:type)
	
	#undef mmat_$(mmat)
	#undef TRANSFORM_ARGUMENTS
																</rsl_code>
			<rsl_include>rsl_shrimp_helpers.h															</rsl_include>
			<usage>A block for the &quot;transform&quot;, &quot;vtransform&quot; and &quot;ntransform&quot; functions, to transform the supplied point &quot;P&quot;, vector &quot;V&quot; or normal &quot;N&quot; respectively, from the coordinate system &quot;fromspace&quot; to the coordinate system &quot;tospace&quot;, with &quot;fromspace&quot; defaulting to &quot;current&quot;. Note that &quot;current&quot; is implementation specific. Predefined coordinate systems are: &quot;current&quot;, &quot;object&quot;, &quot;shader&quot;, &quot;world&quot;, &quot;camera&quot;, &quot;screen&quot;, &quot;raster&quot; and &quot;NDC&quot;. A transformation matrix might be given instead of a &quot;tospace&quot; coordinate system. User defined coordinate systems can also be refered to.															</usage>
		</block>
		<block id="Transform_2" position_x="-4" position_y="-3" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="Point, vector or normal to transform" type_parent="pp">
				<connection parent="p" output="P"/>
			</input>
			<input name="from_space" type="string" storage="uniform" value="&quot;camera&quot;" description="The coordinate system to transform from"/>
			<input name="to_space" type="string" storage="uniform" value="&quot;shader&quot;" description="The coordinate system to transform into"/>
			<input name="mmat" type="matrix" storage="varying" value="UND" description="Use this matrix instead of a predefined coordinate system"/>
			<output name="pp" type="point" storage="varying" description="The transformed point, vector or normal"/>
			<rsl_code>
	#ifdef TRANSFORM_ARGUMENTS
	#undef TRANSFORM_ARGUMENTS
	#endif

	#define mmat_$(mmat)
	#ifdef mmat_UND
		#define TRANSFORM_ARGUMENTS $(to_space)
	#else
		#define TRANSFORM_ARGUMENTS	$(mmat)
	#endif /* mmat_UND */

	#define $(blockname)_$(p:type) 1
	#ifdef $(blockname)_point
		$(pp) = transform( $(from_space), TRANSFORM_ARGUMENTS , $(p) );
	#elif $(blockname)_vector
		$(pp) = vtransform( $(from_space), TRANSFORM_ARGUMENTS , $(p) );
	#elif $(blockname)_normal
		$(pp) = ntransform( $(from_space), TRANSFORM_ARGUMENTS , $(p) );
	#endif /* $(blockname)_$(p:type) */
	#undef $(blockname)_$(p:type)
	
	#undef mmat_$(mmat)
	#undef TRANSFORM_ARGUMENTS
																</rsl_code>
			<rsl_include>rsl_shrimp_helpers.h															</rsl_include>
			<usage>A block for the &quot;transform&quot;, &quot;vtransform&quot; and &quot;ntransform&quot; functions, to transform the supplied point &quot;P&quot;, vector &quot;V&quot; or normal &quot;N&quot; respectively, from the coordinate system &quot;fromspace&quot; to the coordinate system &quot;tospace&quot;, with &quot;fromspace&quot; defaulting to &quot;current&quot;. Note that &quot;current&quot; is implementation specific. Predefined coordinate systems are: &quot;current&quot;, &quot;object&quot;, &quot;shader&quot;, &quot;world&quot;, &quot;camera&quot;, &quot;screen&quot;, &quot;raster&quot; and &quot;NDC&quot;. A transformation matrix might be given instead of a &quot;tospace&quot; coordinate system. User defined coordinate systems can also be refered to.															</usage>
		</block>
		<block id="p" position_x="-4" position_y="-5" author="rconstruct">
			<output name="P" type="point" storage="varying" description="Surface position"/>
			<rsl_code>
    $(P) = P;
    															</rsl_code>
			<rsl_include/>
			<usage>Note that in all shading contexts, &quot;P&quot; is the surface position, the only exception being volume shaders, in which &quot;P&quot; is the light ray origin. Also note that in imager shaders, &quot;P&quot; is the position of the pixel center in raster space, with the z coordinate being 0.															</usage>
		</block>
	</network>
</shrimp>
